d2l <- function(N, b1, b2, theta.old){
result11 <- sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#1st row, 1st col
result12 <- sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#non-principal components
result22 <- sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, ncol = 2, byrow = TRUE))
}
#Fisher Information
I <- function(N, b1, b2, theta.old){
result11 <- sum(N*(sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#1st row, 1st col
result12 <- sum(N*(sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#non-principal components
result22 <- sum(N*(sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, byrow = TRUE))
}
#Newton's Method
new.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(d2l(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
#theta.old <- theta.new
#print(theta.old)
}
return(theta.values)
}
#Fisher Information Approach
fish.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(I(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
#theta.old <- theta.new
#print(theta.old)
}
return(theta.values)
}
#main body of code (i.e. no function definitions)
N <- data.oil$spills
b1 <- data.oil$importexport
b2 <- data.oil$domestic
output.new <- new.oil(N,b1,b2)
output.fish <- fish.oil(N,b1,b2)
#How can I best compare performance of these two functions?
#Use convergence map like in the Givens et al. example?
View(output.fish)
View(output.fish)
View(output.new)
#import data set from Givens et al.
data.oil <- read.table("oilspills.dat",header = TRUE)
#likelihood function
l <- function(N, theta.old){
result <- sum(N*log(theta.old)) - sum(theta.old) - sum(log(factorial(N)))
return(result)
}
#derivative of the likelihood function
dl <- function(N, b1, b2, theta.old){
result1 <- sum((N*b1)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b1))
result2 <- sum((N*b2)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b2))
output <- as.numeric(list(result1,result2))
return(matrix(data = output, ncol = 1))
}
#double derivative of the likelihood function
d2l <- function(N, b1, b2, theta.old){
result11 <- sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#1st row, 1st col
result12 <- sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#non-principal components
result22 <- sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, ncol = 2, byrow = TRUE))
}
#Fisher Information
I <- function(N, b1, b2, theta.old){
result11 <- sum(N*(sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#1st row, 1st col
result12 <- sum(N*(sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#non-principal components
result22 <- sum(N*(sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, byrow = TRUE))
}
#Newton's Method
new.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(d2l(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#Fisher Information Approach
fish.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(I(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#main body of code (i.e. no function definitions)
N <- data.oil$spills
b1 <- data.oil$importexport
b2 <- data.oil$domestic
output.new <- new.oil(N,b1,b2)
output.fish <- fish.oil(N,b1,b2)
#How can I best compare performance of these two functions?
#Use convergence map like in the Givens et al. example?
#import data set from Givens et al.
data.oil <- read.table("oilspills.dat",header = TRUE)
#likelihood function
l <- function(N, theta.old){
result <- sum(N*log(theta.old)) - sum(theta.old) - sum(log(factorial(N)))
return(result)
}
#derivative of the likelihood function
dl <- function(N, b1, b2, theta.old){
result1 <- sum((N*b1)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b1))
result2 <- sum((N*b2)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b2))
output <- as.numeric(list(result1,result2))
return(matrix(data = output, ncol = 1))
}
#double derivative of the likelihood function
d2l <- function(N, b1, b2, theta.old){
result11 <- sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#1st row, 1st col
result12 <- sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#non-principal components
result22 <- sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, ncol = 2, byrow = TRUE))
}
#Fisher Information
I <- function(N, b1, b2, theta.old){
result11 <- sum(N*(sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#1st row, 1st col
result12 <- sum(N*(sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#non-principal components
result22 <- sum(N*(sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, byrow = TRUE))
}
#Newton's Method
new.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(d2l(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#Fisher Information Approach
fish.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old + (solve(I(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#main body of code (i.e. no function definitions)
N <- data.oil$spills
b1 <- data.oil$importexport
b2 <- data.oil$domestic
output.new <- new.oil(N,b1,b2)
output.fish <- fish.oil(N,b1,b2)
#How can I best compare performance of these two functions?
#Use convergence map like in the Givens et al. example?
View(output.fish)
#import data set from Givens et al.
data.oil <- read.table("oilspills.dat",header = TRUE)
#likelihood function
l <- function(N, theta.old){
result <- sum(N*log(theta.old)) - sum(theta.old) - sum(log(factorial(N)))
return(result)
}
#derivative of the likelihood function
dl <- function(N, b1, b2, theta.old){
result1 <- sum((N*b1)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b1))
result2 <- sum((N*b2)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b2))
output <- as.numeric(list(result1,result2))
return(matrix(data = output, ncol = 1))
}
#double derivative of the likelihood function
d2l <- function(N, b1, b2, theta.old){
result11 <- -sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#1st row, 1st col
result12 <- -sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#non-principal components
result22 <- -sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, ncol = 2, byrow = TRUE))
}
#Fisher Information
I <- function(N, b1, b2, theta.old){
result11 <- sum(N*(sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#1st row, 1st col
result12 <- sum(N*(sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#non-principal components
result22 <- sum(N*(sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, byrow = TRUE))
}
#Newton's Method
new.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(d2l(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#Fisher Information Approach
fish.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old + (solve(I(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#main body of code (i.e. no function definitions)
N <- data.oil$spills
b1 <- data.oil$importexport
b2 <- data.oil$domestic
output.new <- new.oil(N,b1,b2)
output.fish <- fish.oil(N,b1,b2)
#How can I best compare performance of these two functions?
#Use convergence map like in the Givens et al. example?
#import data set from Givens et al.
data.oil <- read.table("oilspills.dat",header = TRUE)
#likelihood function
l <- function(N, theta.old){
result <- sum(N*log(theta.old)) - sum(theta.old) - sum(log(factorial(N)))
return(result)
}
#derivative of the likelihood function
dl <- function(N, b1, b2, theta.old){
result1 <- sum((N*b1)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b1))
result2 <- sum((N*b2)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b2))
output <- as.numeric(list(result1,result2))
return(matrix(data = output, ncol = 1))
}
#double derivative of the likelihood function
d2l <- function(N, b1, b2, theta.old){
result11 <- sum(-(N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#1st row, 1st col
result12 <- sum(-(N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#non-principal components
result22 <- sum(-(N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, ncol = 2, byrow = TRUE))
}
#Fisher Information
I <- function(N, b1, b2, theta.old){
result11 <- sum(N*(sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#1st row, 1st col
result12 <- sum(N*(sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#non-principal components
result22 <- sum(N*(sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, byrow = TRUE))
}
#Newton's Method
new.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(d2l(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#Fisher Information Approach
fish.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old + (solve(I(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#main body of code (i.e. no function definitions)
N <- data.oil$spills
b1 <- data.oil$importexport
b2 <- data.oil$domestic
output.new <- new.oil(N,b1,b2)
output.fish <- fish.oil(N,b1,b2)
#How can I best compare performance of these two functions?
#Use convergence map like in the Givens et al. example?
#import data set from Givens et al.
data.oil <- read.table("oilspills.dat",header = TRUE)
#likelihood function
l <- function(N, theta.old){
result <- sum(N*log(theta.old)) - sum(theta.old) - sum(log(factorial(N)))
return(result)
}
#derivative of the likelihood function
dl <- function(N, b1, b2, theta.old){
result1 <- sum((N*b1)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b1))
result2 <- sum((N*b2)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b2))
output <- as.numeric(list(result1,result2))
return(matrix(data = output, ncol = 1))
}
#double derivative of the likelihood function
d2l <- function(N, b1, b2, theta.old){
result11 <- sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#1st row, 1st col
result12 <- sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#non-principal components
result22 <- sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, ncol = 2, byrow = TRUE))
}
#Fisher Information
I <- function(N, b1, b2, theta.old){
result11 <- sum(N*(sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#1st row, 1st col
result12 <- sum(N*(sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#non-principal components
result22 <- sum(N*(sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, byrow = TRUE))
}
#Newton's Method
new.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(d2l(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#Fisher Information Approach
fish.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old + (solve(I(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#main body of code (i.e. no function definitions)
N <- data.oil$spills
b1 <- data.oil$importexport
b2 <- data.oil$domestic
output.new <- new.oil(N,b1,b2)
output.fish <- fish.oil(N,b1,b2)
#How can I best compare performance of these two functions?
#Use convergence map like in the Givens et al. example?
#import data set from Givens et al.
data.oil <- read.table("oilspills.dat",header = TRUE)
#likelihood function
l <- function(N, theta.old){
result <- sum(N*log(theta.old)) - sum(theta.old) - sum(log(factorial(N)))
return(result)
}
#derivative of the likelihood function
dl <- function(N, b1, b2, theta.old){
result1 <- sum((N*b1)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b1))
result2 <- sum((N*b2)/(theta.old[1]*b1 + theta.old[2]*b2)-sum(b2))
output <- as.numeric(list(result1,result2))
return(matrix(data = output, ncol = 1))
}
#double derivative of the likelihood function
d2l <- function(N, b1, b2, theta.old){
result11 <- sum(-(N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#1st row, 1st col
result12 <- sum(-(N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#non-principal components
result22 <- sum(-(N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, ncol = 2, byrow = TRUE))
}
#Fisher Information
I <- function(N, b1, b2, theta.old){
result11 <- sum(N*(sum((N*b1^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#1st row, 1st col
result12 <- sum(N*(sum((N*b1*b2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#non-principal components
result22 <- sum(N*(sum((N*b2^2)/(theta.old[1]*b1 + theta.old[2]*b2)^2)))#2nd row, 2nd col
output <- as.numeric(list(result11,result12,result12,result22))
return(matrix(data = output, nrow = 2, byrow = TRUE))
}
#Newton's Method
new.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old - (solve(d2l(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#Fisher Information Approach
fish.oil <- function(N,b1,b2){
n <- length(N)
i <- 1
theta.old <- matrix(1,2,1)#need it to be a 2x26 matrix, but not sure what initial value to assign to it.
theta.values <- matrix(0,n+1,2)
theta.values[1,] <- theta.old
for(i in 1:n){
theta.new <- theta.old + (solve(I(N,b1,b2,theta.old)) %*% dl(N,b1,b2,theta.old))
theta.values[i+1,] <- theta.new
if(abs(theta.new[1] - theta.old[1]) <= 1e-6){
if(abs(theta.new[2] - theta.old[2]) <= 1e-6){
return(theta.values)
}
}
}
return(theta.values)
}
#main body of code (i.e. no function definitions)
N <- data.oil$spills
b1 <- data.oil$importexport
b2 <- data.oil$domestic
output.new <- new.oil(N,b1,b2)
output.fish <- fish.oil(N,b1,b2)
#How can I best compare performance of these two functions?
#Use convergence map like in the Givens et al. example?
View(output.new)
